<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Interprocesscommunication by Grayson</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Interprocesscommunication</h1>
          <h2>Simple demonstration of using XPC to send messages between macOS apps</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/Grayson/InterprocessCommunication/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/Grayson/InterprocessCommunication/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/Grayson/InterprocessCommunication" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a id="interprocesscommunication" class="anchor" href="#interprocesscommunication" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>InterprocessCommunication</h1>

<p>This is a small document that walks through the general approach to setting up XPC services as implemented in the <a href="https://github.com/Grayson/InterprocessCommunication">InterprocessCommunication repository</a>.  It's not a step-by-step tutorial, but it should demonstrate the basic steps and highlight some of the more important caveats and potential problems.  Not every commit is mentioned, but I'm hoping that the commits are small enough to be easily understandable if you really wanted to see each and every step.</p>

<p>You should also note that this code is not of production quality.  The demonstration is merely a simple example of how to send messages between multiple applications using XPC.  Error handling and proper server/client architecture are not implemented in favor of simplification.</p>

<h2>
<a id="setup" class="anchor" href="#setup" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Setup</h2>

<p>First things first, we set up <a href="https://github.com/Grayson/InterprocessCommunication/commit/23a5082a7dd0845714220d564005dce6dd392c08">two applications in Xcode</a>.  This isn't terribly interesting.  One will be the main application and the second will wind up being a service.  The service is the central application that sends messages back and forth between clients.  The service application (called "Bridge" here) should be a <a href="https://github.com/Grayson/InterprocessCommunication/commit/61cca305d3af8e403c7a06acbae7ee640a2f31ea">background application</a>.  The Bridge app will be built along with the main app and <a href="https://github.com/Grayson/InterprocessCommunication/commit/82c8cb7a718d5a2eee26c676692eae06b56089cd">installed into <code>&lt;app wrapper&gt;/Contents/Library/LoginItems/</code> </a>.</p>

<p>By default, Xcode has added a bit too much to our Bridge application.  It will be built as an app bundle, but it should behave more like a command line application.  To that end, we'll <a href="https://github.com/Grayson/InterprocessCommunication/commit/12650fb490c2d082b4a63df1f97b571e1195f846">remove the <code>@NSApplicationMain</code> tag and add a main.swift file</a>.</p>

<h2>
<a id="creating-a-simple-ping-service" class="anchor" href="#creating-a-simple-ping-service" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creating a simple "Ping" service</h2>

<p>Just to make sure everything is up and running, we'll create a Ping service.  We'll <a href="https://github.com/Grayson/InterprocessCommunication/commit/4e8c0e9493f0a901d6d827e0101986507c14bc89">define a protocol</a> to define this service.  It's very important that this protocol is annotated with <code>@objc</code>.  In several places, the difference between ObjC and Swift will cause problems unless we make our Swift code conform appropriately.</p>

<p>The service is simple.  When it receives a ping, <a href="https://github.com/Grayson/InterprocessCommunication/commit/a08d7c9905196bc5cc27b9827cc3adab7ff7126c#diff-01e4c6bd4b2394b355b3f67e03642028R12">it just responds</a> with the pong.  We then extend our Bridge's main.swift to <a href="https://github.com/Grayson/InterprocessCommunication/commit/d262d61d234041ff13f51ccb4fb5331e77037917">start an NSXPCListener and respond to connections</a>.  For simplicity, the <code>XPCDelegate</code> inherits from <code>NSObject</code>.  This effectively makes it behave as an ObjC object and performs message passing.  It's worth mentioning that registering the listener causes the thread to stop executing.  The Bridge now listens for connections on a background thread.</p>

<h2>
<a id="connecting-to-the-ping-service" class="anchor" href="#connecting-to-the-ping-service" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Connecting to the "Ping" service</h2>

<p>The main application now has two tasks.  It should <a href="https://github.com/Grayson/InterprocessCommunication/commit/a2b5265f77f625058226968822bdd96f7779b7bc">launch the Bridge application and make a connection</a>.  These tasks are relatively simple.  Now, when the main application runs, it will also launch the Bridge app.  The Bridge app will remain running when the main app stops.  When the main app runs, it "pings" the Bridge.  The Bridge then responds and the callback in the main app is executed.</p>

<h2>
<a id="making-things-slightly-more-complicated" class="anchor" href="#making-things-slightly-more-complicated" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Making things slightly more complicated</h2>

<p>A basic ping service is a nice demo and proof that things are working.  However, we may want to actually send more complicated data over the wire.  We'll start by defining some <a href="https://github.com/Grayson/InterprocessCommunication/commit/def379c975170bfb1cf6a515a2a3edd3420c9b40">basic protocols for client and server</a>.  Then, we'll implement a <a href="https://github.com/Grayson/InterprocessCommunication/commit/acc1c441f9dc28c3526d5571143a8ea3dc23063a">basic server</a>.  Note that the server receives <code>NSXPCListenerEndpoint</code>.  This is kept very basic for implementation details.  Alternatively, we could define a "client" object that implemented <code>NSSecureCoding</code> and had a reference to the endpoint, but <code>NSXPCListenerEndpoint</code> implements <code>NSSecureCoding</code> and is the smallest basic building block for what we need.  We create a connection and store them for later.</p>

<p>We also need <a href="https://github.com/Grayson/InterprocessCommunication/commit/03b9a4d58517570d90c7c215f842c077841b977b">an implementation for the Client</a> and we need to <a href="https://github.com/Grayson/InterprocessCommunication/commit/d0bfff31dc9dce62733250a0720bd7455c23194e">extend the main app</a>.  We'll create an anonymous listener and send its endpoint to the Server.</p>

<p>For demonstration purposes, we'll also <a href="https://github.com/Grayson/InterprocessCommunication/commit/67693bbb3f68bd87a3bfb0f58927d2238e7ea592">create a third app</a>.  This third app shares much of its code with the main application.  It was created just to have a differentiated app instance that could demonstrate two (or more) applications speaking to each other through the Bridge.</p>

<p>Now, we can <a href="https://github.com/Grayson/InterprocessCommunication/compare/d0bfff31dc9dce62733250a0720bd7455c23194e...9109598c3fbdb936a7af158e30583a722ae016b9">make a few changes</a> such as creating a UI and displaying the messages received from the Server.  Also, we'll just create <a href="https://github.com/Grayson/InterprocessCommunication/commit/3876136e1c30f69cc448cff3cf5fc58868a73594">one Server instance</a> rather than creating a unique one for each connection.  They'd never see each other otherwise.  With these changes, we can launch the main app and the demo app.  Any message sent from one should appear in the text views of both!</p>

<h2>
<a id="implementing-secure-coding" class="anchor" href="#implementing-secure-coding" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Implementing Secure Coding</h2>

<p>While it's nice to be able to send across basic information (strings, numbers, data, and collection classes like dictionaries and arrays are available, so you may not need much more), you may want to be able to send arbitrary objects over the wire.  To do that, you'll need to implement <code>NSSecureCoding</code>.  There are a few caveats.  We'll start with <a href="https://github.com/Grayson/InterprocessCommunication/commit/f34cf7224e168265624bbe2f460f407158d7187f">this example</a>:</p>

<p>First, you need to make sure that your object can be unambiguously found by the ObjC runtime.  If you have a file that's compiled into multiple projects, they'll be implicitly namespaced.  For this reason, you'll need to stabilize the name.  One tactic would be to put the class into a separate framework and link all projects to it or, more simply, to use the <code>@objc(&lt;name&gt;)</code> property.</p>

<p>Second, your object will need to inherit from <code>NSObject</code> and implement <code>NSSecureCoding</code>.  This involves implementing <code>func encode(with aCoder: NSCoder)</code> and <code>init?(coder aDecoder: NSCoder)</code> as well as <code>static var supportsSecureCoding: Bool</code>.  You should know that <code>NSSecureCoding</code> is a bit stricter than <code>NSCoding</code> (which is expected).  In the decoding, you'll need to specify the expected type of each object.  You'll get exceptions from the decoder if you don't.</p>

<p>Finally, you'll need to tell the XPC interface what to expect.  You'll need to update both the <a href="https://github.com/Grayson/InterprocessCommunication/commit/72067c4821e14961c19774c0ad89b25d6b741846#diff-e82d83dda9eebf856ae78ae4e44b7609R17">server</a> and the <a href="https://github.com/Grayson/InterprocessCommunication/commit/426ad683c2182082c26366761ea0ed3acdcde6f0#diff-82c3bb69f7c35a1ee3ec17901b35ec20R29">client</a>.  This effectively tells the XPC plumbing what to expect.  If it receives something unexpected, you'll have thrown exceptions.</p>
        </section>

        <footer>
          Interprocesscommunication is maintained by <a href="https://github.com/Grayson">Grayson</a><br>
          This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
